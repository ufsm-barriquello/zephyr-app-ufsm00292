üóìÔ∏è Semana 5: Serializa√ß√£o de Dados (Protocol Buffers)
Foco: O servi√ßo NUS √© apenas um "cano" serial. Enviar strings de texto (como "ligar_led") ou JSON √© ineficiente em termos de tamanho de pacote BLE e uso de mem√≥ria/CPU para parsing. Esta semana foi dedicada a implementar um protocolo de dados bin√°rio.

3.1. Diagn√≥stico do Problema
A troca de dados via NUS √© fr√°gil. Se o formato do texto mudar, a aplica√ß√£o quebra. O parsing de strings em um Cortex-M0+ √© custoso.

3.2. Solu√ß√£o: Protocol Buffers (Protobuf) com nanopb
Foi decidido usar Protobuf, um formato de serializa√ß√£o bin√°ria do Google, que √© leve e ideal para embarcados. O Zephyr tem integra√ß√£o nativa com o nanopb, um compilador Protobuf para C.

Modifica√ß√µes no prj.conf:

Snippet de c√≥digo

# --- CONFIGS DE SERIALIZA√á√ÉO (Semana 3) ---

# Habilita o m√≥dulo de Protocol Buffers (que usa nanopb)
CONFIG_PROTOBUF=y
3.3. Defini√ß√£o do Protocolo (.proto)
Criamos um arquivo de defini√ß√£o de protocolo (ex: app_protocol.proto) para nossos comandos:

Arquivo: proto/app_protocol.proto

Protocol Buffers

syntax = "proto3";

message ComandoBT {
  oneof payload {
    ComandoLED led = 1;
    RequisicaoSensor sensor = 2;
  }
}

message ComandoLED {
  uint32 id_led = 1;
  bool estado = 2;
}

message RequisicaoSensor {
  uint32 id_sensor = 1;
}
3.4. Gera√ß√£o e Uso do C√≥digo C
O nanopb (integrado ao build do Zephyr) gera os arquivos app_protocol.pb.c e app_protocol.pb.h a partir do .proto.

Esses arquivos cont√™m as fun√ß√µes pb_encode e pb_decode para serializar e desserializar as structs C.

Modifica√ß√µes no main.c (L√≥gica de Callback do NUS):

Substitu√≠mos o parser de string por um decoder nanopb.

C

/* ... includes de nanopb (pb_encode.h, pb_decode.h) ... */
#include "proto/app_protocol.pb.h"

/* Callback de quando recebemos dados via NUS */
static void nus_data_received(struct bt_nus_client *client, const uint8_t *data, uint16_t len)
{
    // 1. Criar um stream de input para o nanopb
    pb_istream_t stream = pb_istream_from_buffer(data, len);
    
    // 2. Instanciar nossa struct de comando
    ComandoBT comando = ComandoBT_init_zero;

    // 3. Decodificar (parse) a mensagem bin√°ria
    if (!pb_decode(&stream, ComandoBT_fields, &comando)) {
        printk("Erro ao decodificar Protobuf: %s\n", PB_GET_ERROR(&stream));
        return;
    }

    // 4. Agir sobre o comando
    switch (comando.which_payload) {
        case ComandoBT_led_tag:
            printk("Comando LED: ID=%d, Estado=%d\n", 
                   comando.payload.led.id_led, 
                   comando.payload.led.estado);
            // ... l√≥gica para ligar/desligar o LED ...
            break;
        
        case ComandoBT_sensor_tag:
            printk("Requisicao Sensor: ID=%d\n", comando.payload.sensor.id_sensor);
            // ... l√≥gica para ler o sensor e ENVIAR uma resposta (pb_encode) ...
            break;
        
        default:
            printk("Comando desconhecido.\n");
            break;
    }
}
Resultado: A comunica√ß√£o BLE agora √© robusta, eficiente e √† prova de falhas de formato. O payload bin√°rio economiza bytes no pacote BLE (max 251 bytes) e o decoder √© muito mais r√°pido que sscanf ou cJSON.

üóìÔ∏è Semana 4: Implementa√ß√£o de Seguran√ßa (Pairing & Bonding)
Foco: O sample peripheral_nus padr√£o √© inseguro. Ele usa "Just Works" pairing, que n√£o oferece prote√ß√£o contra ataques Man-in-the-Middle (MITM). Esta semana foi dedicada a implementar um link seguro.

1.1. Diagn√≥stico do Problema
Por padr√£o, qualquer smartphone pode se conectar, ler e escrever na caracter√≠stica NUS sem autentica√ß√£o. Para um produto real, isso √© inaceit√°vel.

1.2. Solu√ß√£o: Zephyr Security Manager (SMP)
A solu√ß√£o foi habilitar o SMP (Security Manager Protocol) do Zephyr para for√ßar a autentica√ß√£o antes de permitir o acesso aos servi√ßos.

Modifica√ß√µes no prj.conf:

Adicionamos as seguintes configura√ß√µes de Kconfig para habilitar o SMP e exigir seguran√ßa:

Snippet de c√≥digo

# --- CONFIGS DE SEGURAN√áA (Semana 1) ---

# Habilita o Security Manager Protocol (SMP)
CONFIG_BT_SMP=y

# Exige que a conex√£o seja segura (autenticada e criptografada)
# Isso impede que clientes leiam/escrevam antes do pairing
CONFIG_BT_PERIPHERAL_SEC_REQUIRED=y

# Habilita o armazenamento de chaves (Bonding)
# Permite que o device lembre de um celular pareado
CONFIG_BT_SETTINGS=y
CONFIG_FLASH=y
CONFIG_FLASH_PAGE_LAYOUT=y
CONFIG_FLASH_MAP=y
CONFIG_NVS=y
CONFIG_SETTINGS_NVS_STATISTICS=y
CONFIG_SETTINGS_NVS=y

# Define as capacidades de I/O (ex: se temos tela ou teclado)
# Para um device "headless" (como o Xplained Pro), usamos "NoInputNoOutput"
# Isso for√ßa o "Just Works", mas agora com criptografia (ainda vulner√°vel a MITM)
# MUDAR PARA: CONFIG_BT_SMP_IO_CAP_DISPLAY_ONLY se tiver um console para mostrar um PIN
CONFIG_BT_SMP_IO_CAP_NO_INPUT_NO_OUTPUT=y
1.3. Implementa√ß√£o dos Callbacks de Autentica√ß√£o
Para gerenciar o processo de pairing e bonding, registramos callbacks de conex√£o no main.c:

Modifica√ß√µes no main.c:

C

/* ... includes ... */

/* Callback para mostrar o status da seguran√ßa */
static void security_changed(struct bt_conn *conn, bt_security_t level, enum bt_security_err err)
{
    char addr[BT_ADDR_LE_STR_LEN];
    bt_addr_le_to_str(bt_conn_get_dst(conn), addr, sizeof(addr));

    if (!err) {
        printk("Security changed: %s level %u\n", addr, level);
    } else {
        printk("Security failed: %s level %u err %d\n", addr, level, err);
    }
}

/* Estrutura de callbacks de conex√£o */
static struct bt_conn_cb conn_callbacks = {
    /* ... outros callbacks como connected/disconnected ... */
    .security_changed = security_changed,
};

/* Na fun√ß√£o main() */
int main(void)
{
    /* ... inicializa√ß√£o do BLE (bt_enable) ... */

    // Registrar nossos callbacks de seguran√ßa
    bt_conn_cb_register(&conn_callbacks);

    /* ... resto do c√≥digo ... */
}
Resultado: A conex√£o agora √© criptografada. Um app n√£o consegue mais usar o servi√ßo NUS "de gra√ßa". O pr√≥ximo passo (ainda n√£o implementado) seria usar CONFIG_BT_SMP_IO_CAP_DISPLAY_ONLY e um callback auth_passkey_display para mostrar um PIN no console serial (EDBG), implementando uma prote√ß√£o real contra MITM.
